func (sm *StateMachine) AppendEntriesReq(term uint64, leaderId uint64, prevLogIndex uint64, prevLogTerm uint64, entries LogEntry, leaderCommit uint64) {
	switch sm.state {
//? all three states are similar -- minimize code
		case LEADER :
			if sm.currentTerm > term { //sender is out of date > replay false
				event := CreateEvent("AppendEntriesResp", "term",sm.currentTerm, "success",false, "senderId",sm.id, "forIndex",prevLogIndex)
				sm.actionChan <- CreateAction("Send", "peerId",sm.id, "event",event)
			} else { //I am out of date
				sm.state = FOLLOWER  
				sm.leaderId = leaderId
				if sm.saveState(term,leaderId)!=nil {
					//Problem in saving state
				}

				sm.actionChan <- CreateAction("Alarm", "t",sm.electionTimeout)
				success := sm.appendEntryHelper(prevLogIndex, prevLogTerm, entries,leaderCommit)
				event := CreateEvent("AppendEntriesResp", "term",sm.currentTerm, "success",success, "senderId",sm.id, "forIndex",prevLogIndex)
				sm.actionChan <- CreateAction("Send", "peerId",sm.id, "event",event)
			}
		case CANDIDATE :
			if term >= sm.currentTerm {
//copy of above
				sm.state = FOLLOWER  
				sm.leaderId = leaderId
				if sm.saveState(term,leaderId)!=nil {
					//Problem in saving state
				}
				sm.actionChan <- CreateAction("Alarm", "t",sm.electionTimeout)
				success := sm.appendEntryHelper(prevLogIndex, prevLogTerm, entries,leaderCommit)
				event := CreateEvent("AppendEntriesResp", "term",sm.currentTerm, "success",success, "senderId",sm.id, "forIndex",prevLogIndex)
				sm.actionChan <- CreateAction("Send", "peerId",sm.id, "event",event)
			} else { //sender is out of date > replay false
				event := CreateEvent("AppendEntriesResp", "term",sm.currentTerm, "success",false, "senderId",sm.id, "forIndex",prevLogIndex)
				sm.actionChan <- CreateAction("Send", "peerId",sm.id, "event",event)
			}
		case FOLLOWER :
			if term >= sm.currentTerm {
//copy of above
				sm.leaderId = leaderId
				if sm.saveState(term,leaderId)!=nil {
					//Problem in saving state
				}
				sm.actionChan <- CreateAction("Alarm", "t",sm.electionTimeout)
				success := sm.appendEntryHelper(prevLogIndex, prevLogTerm, entries,leaderCommit)
				event := CreateEvent("AppendEntriesResp", "term",sm.currentTerm, "success",success, "senderId",sm.id, "forIndex",prevLogIndex)
				sm.actionChan <- CreateAction("Send", "peerId",sm.id, "event",event)
			} else { //sender is out of date > replay false
				event := CreateEvent("AppendEntriesResp", "term",sm.currentTerm, "success",false, "senderId",sm.id, "forIndex",prevLogIndex)
				sm.actionChan <- CreateAction("Send", "peerId",sm.id, "event",event)
			}
	}
}


func (sm *StateMachine) appendEntryHelper(prevLogIndex uint64, prevLogTerm uint64, entries LogEntry, leaderCommit uint64) (bool){
	if uint64(len(sm.log)) > prevLogIndex && sm.log[prevLogIndex].term == prevLogTerm {
		if entries.valid == false { //heartbeat message
			return true
		}
		sm.addToLog(entries,prevLogIndex+1)
		if leaderCommit > sm.commitIndex {
			if sm.logIndex < leaderCommit {
				sm.commitIndex = sm.logIndex
			} else {
				sm.commitIndex = leaderCommit
			}
		}
		return true		
	}
	return false	//else false
}

